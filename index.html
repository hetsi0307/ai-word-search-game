<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Word Search Game</title>
     <!-- ‚úÖ Google Search Console Verification -->
    <meta name="google-site-verification" content="google8bc915fd96e92dd6" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* UPDATED: white ‚Üí light sky blue gradient and removed old animated gradient */
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(180deg, #ffffff 0%, #87cefa 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Optional: keep floating shapes but push further back */
        .floating-shapes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -2; /* behind bubbles */
        }

        .shape { position: absolute; opacity: 0.08; animation: float 20s infinite linear; }
        .shape:nth-child(1) { left: 10%; animation-delay: 0s; }
        .shape:nth-child(2) { left: 20%; animation-delay: 2s; }
        .shape:nth-child(3) { left: 30%; animation-delay: 4s; }
        .shape:nth-child(4) { left: 40%; animation-delay: 6s; }
        .shape:nth-child(5) { left: 50%; animation-delay: 8s; }
        .shape:nth-child(6) { left: 60%; animation-delay: 10s; }
        .shape:nth-child(7) { left: 70%; animation-delay: 12s; }
        .shape:nth-child(8) { left: 80%; animation-delay: 14s; }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }

        /* ADDED: bubbles background animation */
        .bubbles { position: fixed; inset: 0; z-index: -1; overflow: hidden; }
        .bubble {
            position: absolute; bottom: -150px; background: rgba(255, 255, 255, 0.35);
            border-radius: 50%; filter: blur(0.2px); animation: rise 20s infinite ease-in;
            box-shadow: inset -4px -8px 12px rgba(255,255,255,0.6),
                        inset 3px 6px 10px rgba(135,206,250,0.25);
        }
        @keyframes rise {
            0% { transform: translateY(0) translateX(0) scale(1); opacity: 0.75; }
            50% { transform: translateY(-55vh) translateX(20px) scale(1.1); opacity: 0.9; }
            100% { transform: translateY(-115vh) translateX(-10px) scale(1.25); opacity: 0; }
        }

        .stars { display: none; }

        .container { max-width: 1200px; margin: 0 auto; padding: 20px; position: relative; z-index: 1; }
        .header { text-align: center; margin-bottom: 30px; transform: perspective(1000px) rotateX(10deg); animation: headerFloat 3s ease-in-out infinite alternate; }
        @keyframes headerFloat { 0% { transform: perspective(1000px) rotateX(10deg) translateY(0px); } 100% { transform: perspective(1000px) rotateX(10deg) translateY(-10px); } }

        h1 {
            color: #0b2239; font-size: 3rem; text-shadow: 0 10px 20px rgba(0,0,0,0.05), 0 0 30px rgba(255,255,255,0.15);
            margin-bottom: 10px; font-weight: bold;
        }

        .controls { display: flex; justify-content: center; gap: 20px; margin-bottom: 30px; flex-wrap: wrap; }
        select, button {
            padding: 12px 20px; font-size: 16px; border: none; border-radius: 15px;
            background: rgba(255,255,255,0.6); color: #0b2239; backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(11,34,57,0.08); cursor: pointer; transition: all 0.3s ease;
            transform: perspective(1000px) rotateY(0deg);
        }
        select:hover, button:hover { transform: perspective(1000px) rotateY(5deg) scale(1.05); box-shadow: 0 12px 40px rgba(11,34,57,0.14); }
        select option { background: #0b2239; color: white; }

        .game-area { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; }
        .grid-container {
            background: rgba(255,255,255,0.8); backdrop-filter: blur(15px); border-radius: 20px; padding: 20px;
            box-shadow: 0 20px 60px rgba(11,34,57,0.12); transform: perspective(1000px) rotateX(5deg); transition: transform 0.3s ease;
        }
        .grid-container:hover { transform: perspective(1000px) rotateX(0deg) scale(1.02); }

        .word-grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 2px; margin-bottom: 20px; }
        .cell {
            width: 35px; height: 35px; background: rgba(255,255,255,0.95); display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 14px; cursor: pointer; border-radius: 8px; transition: all 0.3s ease;
            transform: perspective(500px) rotateZ(0deg); box-shadow: 0 4px 8px rgba(11,34,57,0.08); color: #0b2239;
        }
        .cell:hover { transform: perspective(500px) rotateZ(5deg) scale(1.1); background: #ffffff; box-shadow: 0 6px 12px rgba(11,34,57,0.16); }
        .cell.selected { background: #4ecdc4; color: white; transform: perspective(500px) rotateZ(0deg) scale(1.1); animation: pulse 0.5s ease; }
        .cell.found { background: #2ecc71; color: white; animation: foundAnimation 0.8s ease; }
        @keyframes pulse { 0% { transform: perspective(500px) rotateZ(0deg) scale(1.1); } 50% { transform: perspective(500px) rotateZ(0deg) scale(1.2); } 100% { transform: perspective(500px) rotateZ(0deg) scale(1.1); } }
        @keyframes foundAnimation { 0% { transform: scale(1) rotateZ(0deg); } 50% { transform: scale(1.3) rotateZ(180deg); } 100% { transform: scale(1) rotateZ(360deg); } }

        .words-list {
            background: rgba(255,255,255,0.8); backdrop-filter: blur(15px); border-radius: 20px; padding: 20px;
            box-shadow: 0 20px 60px rgba(11,34,57,0.12); max-width: 250px; transform: perspective(1000px) rotateY(-5deg);
            transition: transform 0.3s ease;
        }
        .words-list:hover { transform: perspective(1000px) rotateY(0deg) scale(1.02); }
        .words-list h3 { color: #0b2239; margin-bottom: 15px; text-align: center; font-size: 1.5rem; }
        .word-item {
            padding: 8px 12px; margin: 5px 0; background: rgba(255,255,255,0.9); border-radius: 10px; color: #0b2239;
            transition: all 0.3s ease; transform: perspective(500px) rotateX(0deg); box-shadow: 0 6px 14px rgba(11,34,57,0.06);
        }
        .word-item:hover { transform: perspective(500px) rotateX(10deg) scale(1.05); }
        .word-item.found { background: #2ecc71; color: #ffffff; text-decoration: line-through; animation: wordFound 0.6s ease; }
        @keyframes wordFound { 0% { transform: scale(1) rotateY(0deg); } 50% { transform: scale(1.1) rotateY(180deg); } 100% { transform: scale(1) rotateY(360deg); } }

        .score { text-align: center; margin-top: 20px; color: #0b2239; font-size: 1.2rem; background: white; border: 2px solid #e7eef6; padding: 10px; border-radius: 10px; font-weight: 500; }

        .celebration {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95); padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 60px rgba(11,34,57,0.25); z-index: 1000; animation: celebrationPop 0.5s ease; display: none;
        }
        @keyframes celebrationPop { 0% { transform: translate(-50%, -50%) scale(0) rotateZ(0deg); } 50% { transform: translate(-50%, -50%) scale(1.1) rotateZ(180deg); } 100% { transform: translate(-50%, -50%) scale(1) rotateZ(360deg); } }

        .particle { position: absolute; width: 10px; height: 10px; background: #ff6b6b; border-radius: 50%; pointer-events: none; animation: particleFloat 2s ease-out forwards; }
        @keyframes particleFloat { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-100px) scale(0); opacity: 0; } }

        @media (max-width: 768px) {
            .game-area { flex-direction: column; align-items: center; }
            h1 { font-size: 2rem; }
            .cell { width: 30px; height: 30px; font-size: 12px; }
        }
    </style>
</head>
<body>
    <div class="floating-shapes">
        <div class="shape">üåü</div><div class="shape">‚≠ê</div><div class="shape">‚ú®</div><div class="shape">üîç</div>
        <div class="shape">üìù</div><div class="shape">üéØ</div><div class="shape">üèÜ</div><div class="shape">üéÆ</div>
    </div>

    <div class="bubbles">
        <div class="bubble" style="left: 8%;  width: 38px; height: 38px; animation-duration: 21s; animation-delay: 0s;"></div>
        <div class="bubble" style="left: 18%; width: 24px; height: 24px; animation-duration: 24s; animation-delay: 1s;"></div>
        <div class="bubble" style="left: 28%; width: 56px; height: 56px; animation-duration: 20s; animation-delay: 0.6s;"></div>
        <div class="bubble" style="left: 42%; width: 30px; height: 30px; animation-duration: 26s; animation-delay: 1.2s;"></div>
        <div class="bubble" style="left: 56%; width: 62px; height: 62px; animation-duration: 23s; animation-delay: 0.4s;"></div>
        <div class="bubble" style="left: 68%; width: 22px; height: 22px; animation-duration: 19s; animation-delay: 0.9s;"></div>
        <div class="bubble" style="left: 78%; width: 44px; height: 44px; animation-duration: 25s; animation-delay: 0.3s;"></div>
        <div class="bubble" style="left: 88%; width: 28px; height: 28px; animation-duration: 22s; animation-delay: 1.4s;"></div>
    </div>

    <div class="stars"><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div><div class="star"></div></div>

    <div class="container">
        <div class="header">
            <h1>3D Word Search Adventure</h1>
            <p style="color: rgba(11,34,57,0.75); font-size: 1.1rem;">Find all the hidden words!</p>
        </div>

        <div class="controls">
            <select id="categorySelect">
                <option value="nature">üåø Nature</option>
                <option value="education">üìö Education</option>
                <option value="sports">‚öΩ Sports</option>
                <option value="beach">üèñÔ∏è Beach</option>
                <option value="food">üçï Food</option>
                <option value="technology">üíª Technology</option>
            </select>
            <button id="newGameBtn">üéÆ New Game</button>
            <button id="hintBtn">üí° Hint</button>
        </div>

        <div class="game-area">
            <div class="grid-container">
                <div class="word-grid" id="wordGrid"></div>
                <div class="score">
                    <div>Found: <span id="foundCount">0</span> / <span id="totalCount">0</span></div>
                    <div>Time: <span id="timer">00:00</span></div>
                </div>
            </div>

            <div class="words-list">
                <h3>Find These Words:</h3>
                <div id="wordsList"></div>
            </div>
        </div>
    </div>

    <div class="celebration" id="celebration">
        <h2>üéâ Congratulations! üéâ</h2>
        <p>You found all the words!</p>
        <p>Time: <span id="finalTime"></span></p>
        <button onclick="startNewGame()" style="margin-top: 20px;">Play Again</button>
    </div>

    <script>
        const categories = {
            nature: ['TREE', 'FLOWER', 'RIVER', 'MOUNTAIN', 'FOREST', 'BIRD', 'OCEAN', 'LEAF'],
            education: ['BOOK', 'PENCIL', 'SCHOOL', 'TEACHER', 'STUDENT', 'LEARN', 'STUDY', 'EXAM'],
            sports: ['FOOTBALL', 'TENNIS', 'BASKETBALL', 'SOCCER', 'GOLF', 'SWIM', 'RUN', 'JUMP'],
            beach: ['SAND', 'WAVE', 'SHELL', 'SURF', 'SUN', 'PALM', 'TIDE', 'CORAL'],
            food: ['PIZZA', 'BURGER', 'PASTA', 'SALAD', 'FRUIT', 'BREAD', 'CHEESE', 'MILK'],
            technology: ['COMPUTER', 'PHONE', 'INTERNET', 'CODE', 'DATA', 'ROBOT', 'AI', 'CYBER']
        };

        let currentGrid = [];
        let currentWords = [];
        let foundWords = [];
        let selectedCells = [];
        let isSelecting = false;
        let gameTime = 0;
        let gameTimer;

        // Track last chosen 6-word set per category to avoid exact repeats.
        const lastWordsByCategory = {};
        const keyOf = arr => arr.slice().sort().join('|');

        // Shuffle/sample helper
        function pickRandomWords(pool, count = 6) {
            const copy = [...pool];
            for (let i = copy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [copy[i], copy[j]] = [copy[j], copy[i]];
            }
            return copy.slice(0, Math.min(count, copy.length));
        }

        // Returns a new 6-word set that isn't identical to the last one used for this category
        function pickNewWords(category) {
            const pool = categories[category];
            const count = Math.min(6, pool.length);
            const lastKey = lastWordsByCategory[category] || '';
            let tries = 0, choice, choiceKey;

            do {
                choice = pickRandomWords(pool, count);
                choiceKey = keyOf(choice);
                tries++;
            } while (tries < 20 && choiceKey === lastKey); // avoid immediate repeat

            lastWordsByCategory[category] = choiceKey;
            return choice;
        }

        function initializeGame() {
            const categorySelect = document.getElementById('categorySelect');
            const selectedCategory = categorySelect.value;

            // NEW: fresh set each game, guaranteed different from previous set for that category
            currentWords = pickNewWords(selectedCategory);

            foundWords = [];
            selectedCells = [];
            gameTime = 0;

            generateGrid();
            updateWordsDisplay();
            updateScore();
            startTimer();

            document.getElementById('celebration').style.display = 'none';
        }

        function generateGrid() {
            const gridSize = 12;
            currentGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));

            // Place words in grid
            currentWords.forEach(word => {
                placeWordInGrid(word, gridSize);
            });

            // Fill empty cells with random letters
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (currentGrid[i][j] === '') {
                        currentGrid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }

            renderGrid();
        }

        function placeWordInGrid(word, gridSize) {
            const directions = [
                [0, 1],   // horizontal ‚Üí
                [1, 0],   // vertical ‚Üì
                [1, 1],   // diagonal ‚ÜòÔ∏é
                [-1, 1],  // diagonal ‚ÜóÔ∏é
            ];

            let placed = false;
            let attempts = 0;

            while (!placed && attempts < 100) {
                const direction = directions[Math.floor(Math.random() * directions.length)];
                const startRow = Math.floor(Math.random() * gridSize);
                const startCol = Math.floor(Math.random() * gridSize);

                if (canPlaceWord(word, startRow, startCol, direction, gridSize)) {
                    for (let i = 0; i < word.length; i++) {
                        const row = startRow + i * direction[0];
                        const col = startCol + i * direction[1];
                        currentGrid[row][col] = word[i];
                    }
                    placed = true;
                }
                attempts++;
            }
        }

        function canPlaceWord(word, startRow, startCol, direction, gridSize) {
            for (let i = 0; i < word.length; i++) {
                const row = startRow + i * direction[0];
                const col = startCol + i * direction[1];

                if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) return false;
                if (currentGrid[row][col] !== '' && currentGrid[row][col] !== word[i]) return false;
            }
            return true;
        }

        function renderGrid() {
            const gridElement = document.getElementById('wordGrid');
            gridElement.innerHTML = '';

            for (let i = 0; i < currentGrid.length; i++) {
                for (let j = 0; j < currentGrid[i].length; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = currentGrid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    cell.addEventListener('mousedown', startSelection);
                    cell.addEventListener('mouseenter', continueSelection);
                    cell.addEventListener('mouseup', endSelection);

                    gridElement.appendChild(cell);
                }
            }
        }

        function startSelection(e) {
            isSelecting = true;
            selectedCells = [e.target];
            e.target.classList.add('selected');
            createParticle(e.target);
        }

        function continueSelection(e) {
            if (!isSelecting) return;

            const lastCell = selectedCells[selectedCells.length - 1];
            if (isAdjacent(lastCell, e.target) && !selectedCells.includes(e.target)) {
                selectedCells.push(e.target);
                e.target.classList.add('selected');
                createParticle(e.target);
            }
        }

        function endSelection() {
            if (!isSelecting) return;

            isSelecting = false;
            const selectedWord = selectedCells.map(cell => cell.textContent).join('');

            if (currentWords.includes(selectedWord) && !foundWords.includes(selectedWord)) {
                foundWords.push(selectedWord);
                selectedCells.forEach(cell => {
                    cell.classList.remove('selected');
                    cell.classList.add('found');
                });
                updateWordsDisplay();
                updateScore();

                if (foundWords.length === currentWords.length) endGame();
            } else {
                selectedCells.forEach(cell => cell.classList.remove('selected'));
            }

            selectedCells = [];
        }

        function isAdjacent(cell1, cell2) {
            const row1 = parseInt(cell1.dataset.row);
            const col1 = parseInt(cell1.dataset.col);
            const row2 = parseInt(cell2.dataset.row);
            const col2 = parseInt(cell2.dataset.col);

            const rowDiff = Math.abs(row1 - row2);
            const colDiff = Math.abs(col1 - col2);

            return (rowDiff <= 1 && colDiff <= 1) && !(rowDiff === 0 && colDiff === 0);
        }

        function updateWordsDisplay() {
            const wordsListElement = document.getElementById('wordsList');
            wordsListElement.innerHTML = '';

            currentWords.forEach(word => {
                const wordElement = document.createElement('div');
                wordElement.className = 'word-item';
                wordElement.textContent = word;

                if (foundWords.includes(word)) wordElement.classList.add('found');
                wordsListElement.appendChild(wordElement);
            });
        }

        function updateScore() {
            document.getElementById('foundCount').textContent = foundWords.length;
            document.getElementById('totalCount').textContent = currentWords.length;
        }

        function startTimer() {
            clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                gameTime++;
                const minutes = Math.floor(gameTime / 60);
                const seconds = gameTime % 60;
                document.getElementById('timer').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function endGame() {
            clearInterval(gameTimer);
            const finalTime = document.getElementById('timer').textContent;
            document.getElementById('finalTime').textContent = finalTime;
            document.getElementById('celebration').style.display = 'block';

            for (let i = 0; i < 20; i++) {
                setTimeout(() => createCelebrationParticle(), i * 100);
            }
        }

        function createParticle(element) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = element.offsetLeft + element.offsetWidth / 2 + 'px';
            particle.style.top = element.offsetTop + element.offsetHeight / 2 + 'px';
            particle.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
            element.parentNode.appendChild(particle);

            setTimeout(() => particle.remove(), 2000);
        }

        function createCelebrationParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * window.innerWidth + 'px';
            particle.style.top = Math.random() * window.innerHeight + 'px';
            particle.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
            particle.style.animationDelay = Math.random() * 1000 + 'ms';
            document.body.appendChild(particle);

            setTimeout(() => particle.remove(), 2000);
        }

        function startNewGame() { initializeGame(); }

        function giveHint() {
            const remainingWords = currentWords.filter(word => !foundWords.includes(word));
            if (remainingWords.length > 0) {
                const hintWord = remainingWords[Math.floor(Math.random() * remainingWords.length)];
                alert(`Hint: Look for the word "${hintWord}"`);
            }
        }

        document.getElementById('categorySelect').addEventListener('change', initializeGame);
        document.getElementById('newGameBtn').addEventListener('click', startNewGame);
        document.getElementById('hintBtn').addEventListener('click', giveHint);

        document.addEventListener('selectstart', e => e.preventDefault());

        initializeGame();
    </script>

  <!-- CTA Section -->
  <div style="text-align: center; margin: 50px auto; max-width: 700px; padding: 25px; 
              background: #0b2239; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.2);">
      <h2 style="color: #ffffff; font-size: 1.8rem; margin-bottom: 15px;">
          üéÆ Had fun playing?
      </h2>
      <p style="color: #e0e0e0; font-size: 1.1rem; margin-bottom: 20px;">
          Curious how I built this game? Check out my full portfolio for more projects!
      </p>
      <a href="https://hetsi0307.github.io/" target="_blank"
         style="display: inline-block; padding: 12px 28px; background: #4ecdc4; color: #0b2239; 
                font-size: 1.1rem; font-weight: bold; text-decoration: none; border-radius: 8px; 
                transition: background 0.3s ease;">
          üöÄ Visit My Portfolio
      </a>
  </div>
</body>
</html>

